{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Real Gas FROzen SHock (RGFROSH)","text":"<p>This project is a solver for the frozen shock equations<sup>1</sup> developed in Python at the University of Central Florida. The original RGFROSH was developed in FORTRAN at Stanford  University by D. F. Davidson and R. K. Hanson using real gas subroutines for  CHEMKIN<sup>2</sup><sup>,</sup><sup>3</sup>. </p> <p>Python RGFROSH (<code>rgfrosh</code>) is a package for calculating conditions behind incident and reflected shock in a shock tube. As its name suggests, <code>rgfrosh</code> was written primarily for solving the frozen shock equations for a real gas equation of state; however, the implementation also allows for the use of the ideal gas equation of state or  even custom equations of state. Additionally, an implementation of the ideal shock equations is also available for comparison. </p> <p>See the user guide for information on how to get started with <code>rgfrosh</code>.</p>"},{"location":"#installation","title":"Installation","text":"<p>Python RGFROSH can be installed using</p> <pre><code>pip install rgfrosh\n</code></pre> <p>which also installs required dependencies. Cantera or CoolProp are optional and must  be installed separately if desired.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>For any bugs or feature requests, create an issue on the  issue tracker. </p> <p>After cloning the repository, the development environment can be set up with</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Before creating a pull request, be sure to lint</p> <pre><code>black .\n</code></pre> <p>and run the automated tests</p> <pre><code>pytest\n</code></pre> <p>These checks will be performed automatically for all pull requests along with test coverage comparisons.</p>"},{"location":"#cite","title":"Cite","text":"<p>To cite Python RGFROSH go to the GitHub repository and click  Cite this repository on the right side of the page to export the citation for the latest  release of <code>rgfrosh</code>. It is also encouraged to cite the original paper<sup>1</sup> for the frozen shock  equations that this work is a derivative of.</p> <ol> <li> <p>Davidson, D.F. and Hanson, R.K. (1996), Real Gas Corrections in Shock Tube Studies  at High Pressures. Isr. J. Chem., 36: 321-326.  https://doi.org/10.1002/ijch.199600044 \u21a9\u21a9</p> </li> <li> <p>P. Barry Butler, \"Real Gas Equations of State for Chemkin\" Sandia Report No.  SAND88-3188 (1988). https://doi.org/10.2172/6224858 \u21a9</p> </li> <li> <p>R. G. Schmitt, P. B. Butler, N. B. French \"Chemkin real gas: a Fortran package for  analaysis of thermodynamic properties and chemical kinetics in non-ideal systems,\"  U. of Iowa Report UIME PPB 93-006 (1994).\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Vasu Lab</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>The main function of <code>rgfrosh</code> is to solve the conservation equations across an incident and reflected shock in a shock tube. <code>rgfrosh</code> does not itself perform any calculations to evaluate  the thermodynamic properties of the gas; therefore, an interface to an external set of thermodynamics  routines is required. The following are currently supported:</p> <ul> <li>Cantera (natively)</li> <li>CoolProp (through the built-in wrapper)</li> <li>User-defined interfaces</li> </ul> <p>For more detailed information and examples see the thermodynamic interfaces page.</p>"},{"location":"guide/getting-started/#experiment-analysis","title":"Experiment Analysis","text":"<p>The primary use case of <code>rgfrosh</code> is using the <code>FrozenShock</code> class can to calculate shock conditions for an experiment from the initial conditions and  measured shock velocity. For example, using Cantera's built-in carbon dioxide EOS:</p> <pre><code>from rgfrosh import FrozenShock\nimport cantera as ct\n\nshock = FrozenShock(ct.CarbonDioxide(), u1=1000, P1=101325)  # (1)!\n\nprint(f\"T2 = {shock.T2:.1f} K, P2 = {shock.P2 / 101325:.2f} atm\")\nprint(f\"T5 = {shock.T5:.1f} K, P5 = {shock.P5 / 101325:.2f} atm\")\n</code></pre> <ol> <li>If not given, <code>T1</code> is <code>300</code> by default.</li> </ol> <p>which outputs the following incident and reflected shock conditions:</p> <pre><code>T2 = 774.8 K, P2 = 15.82 atm\nT5 = 1225.1 K, P5 = 113.33 atm\n</code></pre> Note <p>The <code>IdealShock</code> class implements the exact same constructor pattern, except it requires the positional arguments <code>gamma</code> and <code>MW</code> instead of a  <code>ThermoInterface</code> object. Therefore, the same calculation would look like:</p> <pre><code>from rgfrosh import IdealShock\n\nshock = IdealShock(1.29, 44, u1=1000, P1=101325)  # Carbon Dioxide\n\nprint(f\"T2 = {shock.T2:.1f} K, P2 = {shock.P2 / 101325:.2f} atm\")\nprint(f\"T5 = {shock.T5:.1f} K, P5 = {shock.P5 / 101325:.2f} atm\")\n</code></pre> <p>which outputs:</p> <pre><code>T2 = 873.2 K, P2 = 15.28 atm\nT5 = 1559.5 K, P5 = 99.03 atm\n</code></pre> <p>Comparison with the frozen shock solution for the same example demonstrates  the unsuitability of the ideal shock equations for certain conditions.</p>"},{"location":"guide/getting-started/#experiment-planning","title":"Experiment Planning","text":"<p>The other use case of <code>rgfrosh</code> is to plan experiments by calculating the required  initial conditions for target  reflected shock conditions:</p> <pre><code>from rgfrosh import FrozenShock\nimport cantera as ct\n\nshock = FrozenShock(ct.CarbonDioxide(), T5=1100, P5=200e5, T1=295)\n\nprint(f\"P1 = {shock.P1 / 133.322:.0f} torr, u1 = {shock.u1:.1f} m/s\")\n</code></pre> <p>which outputs the required fill pressure and incident shock velocity:</p> <pre><code>P1 = 1640 torr, u1 = 920.9 m/s\n</code></pre>"},{"location":"guide/thermodynamic-interfaces/","title":"Thermodynamic Interfaces","text":""},{"location":"guide/thermodynamic-interfaces/#cantera","title":"Cantera","text":"<p><code>rgfrosh</code> has native support for <code>cantera.ThermoPhase</code> instances.</p> <p>Notice</p> <p>The implementations of the Redlich-Kwong (RK) EOS and Peng-Robinson (PR) EOS in Cantera do not yet include definitions for <code>isothermal_compressibility</code> and <code>thermal_expansion_coeff</code> (see Cantera/cantera/pull/1421), thus only the ideal gas EOS is currently supported.</p>"},{"location":"guide/thermodynamic-interfaces/#coolprop","title":"CoolProp","text":"<p>The <code>CPInterface</code> wrapper is provided to enable straightforward use of <code>CoolProp.AbstractState</code> instances with <code>rgfrosh</code>:</p> <pre><code>from rgfrosh import FrozenShock\nfrom rgfrosh.thermo import CPInterface\nimport CoolProp as CP\n\nstate = CP.AbstractState(\"PR\", \"Argon\")  # Peng-Robinson\nstate.specify_phase(CP.iphase_supercritical_gas)  # (1)!\n\nshock = FrozenShock(CPInterface(state), u1=763, T1=293, P1=(10 * 101325))\n</code></pre> <ol> <li>Specifying phase is necessary if the cubic has three roots</li> </ol>"},{"location":"guide/thermodynamic-interfaces/#user-defined-interfaces","title":"User-defined Interfaces","text":"<p>If you would like to use <code>rgfrosh</code> with thermodynamic routines other than Cantera or  CoolProp, all you have to do is pass an object that matches the pattern defined by the  <code>ThermoInterface</code> class.</p> <p>Note</p> <p>The <code>ThermoInterface</code> class utilizes structural  subtyping (see PEP 544) through the  built-in <code>typing.Protocol</code> base class. Thus, any class that implements the required methods is considered a  subtype, even if it is not an explicit subclass of <code>ThermoInterface</code>; however,  explicitly subclassing <code>ThermoInterface</code> is recommended for user-defined  interfaces to ensure all required methods are defined.</p> <p>Below is a simple example implementation of an interface for a calorically perfect gas:</p> <pre><code>from rgfrosh import ThermoInterface\nfrom rgfrosh.constants import GAS_CONSTANT\n\n\nclass PerfectGas(ThermoInterface):\n    \"\"\"Thermo interface for a calorically perfect gas.\"\"\"\n\n    def __init__(self, gamma, MW):\n        self._T = 300\n        self._P = 101325\n        self.gamma = gamma\n        self.MW = MW\n\n    @property\n    def TP(self):\n        return self._T, self._P\n\n    @TP.setter\n    def TP(self, value):\n        self._T, self._P = value\n\n    @property\n    def mean_molecular_weight(self):\n        return self.MW\n\n    @property\n    def density_mass(self):\n        return self._P / (GAS_CONSTANT / self.MW * self._T)\n\n    @property\n    def cp_mass(self):\n        return self.gamma / (self.gamma - 1) * GAS_CONSTANT / self.MW\n\n    @property\n    def enthalpy_mass(self):\n        return self.cp_mass * self._T\n\n    @property\n    def isothermal_compressibility(self):\n        return 1 / self._P\n\n    @property\n    def thermal_expansion_coeff(self):\n        return 1 / self._T\n</code></pre> <p>The interface can then be used with <code>FrozenShock</code>:</p> <pre><code>from rgfrosh import FrozenShock\n\nargon = PerfectGas(5/3, 40)\nfrozen_shock = FrozenShock(argon, u1=750, P1=101325)\n\nprint(f\"T5 = {frozen_shock.T5:.1f} K, P5 = {frozen_shock.P5 / 101325:.2f} atm\")\n</code></pre> <p>which yields the reflected shock conditions:</p> <pre><code>T5 = 1353.9 K, P5 = 23.60 atm\n</code></pre> <p>For the case of a calorically perfect gas, the frozen shock solution should simplify to the ideal shock solution. We can use the custom interface with the  <code>IdealShock.from_thermo</code> classmethod to verify this:</p> <pre><code>from rgfrosh import IdealShock\n\nideal_shock = IdealShock.from_thermo(argon, u1=750, P1=101325)\n\nprint(f\"T5 = {frozen_shock.T5:.1f} K, P5 = {frozen_shock.P5 / 101325:.2f} atm\")\n</code></pre> <p>which yields approximately the same solution:</p> <pre><code>T5 = 1353.9 K, P5 = 23.60 atm\n</code></pre>"},{"location":"reference/","title":"<code>rgfrosh</code> Reference","text":""},{"location":"reference/#api","title":"API","text":"<p>The following classes are available at the package level:</p> <ul> <li><code>rgfrosh.FrozenShock</code></li> <li><code>rgfrosh.IdealShock</code></li> <li><code>rgfrosh.ThermoInterface</code></li> <li><code>rgfrosh.ConvergenceError</code></li> </ul> <p>All definitions are contained within the following submodules:</p> <ul> <li><code>rgfrosh.shock</code></li> <li><code>rgfrosh.thermo</code></li> <li><code>rgfrosh.errors</code></li> <li><code>rgfrosh.constants</code></li> </ul>"},{"location":"reference/#theory","title":"Theory","text":"<p>The standard shock tube region notation is observed:</p> Region Description 1 Initial driven gas state 2 Post-incident-shock driven gas state 3 Expanded driver gas state 4 Initial driver gas state 5 Post-reflected-shock driven gas state"},{"location":"reference/#conservation-equations","title":"Conservation Equations","text":""},{"location":"reference/#incident-shock","title":"Incident Shock","text":"<p>The conservation of mass, momentum, and energy equations across a normal shock are:</p> \\[ \\rho_1 u_1 = \\rho_2 u_2 \\] \\[ P_1 + \\rho_1 {u_1}^2 = P_2 + \\rho_2 {u_2}^2 \\] \\[ h_1 + \\tfrac{1}{2} {u_1}^2 = h_2 + \\tfrac{1}{2} {u_2}^2 \\]"},{"location":"reference/#reflected-shock","title":"Reflected Shock","text":"<p>Similarly, the conservation equations for the reflected shock are:</p> \\[ \\rho_2 u_2' = \\rho_5 u_5 \\] \\[ P_2 + \\rho_2 {u_2'}^2 = P_5 + \\rho_5 {u_5}^2 \\] \\[ h_2 + \\tfrac{1}{2} {u_2'}^2 = h_5 + \\tfrac{1}{2} {u_5}^2 \\] <p>where \\(u_2'\\) is the velocity of the gas in the incident shock region relative to the reflected shock:</p> \\[ u_2' = u_5 + u_1 - u_2 \\]"},{"location":"reference/constants/","title":"<code>rgfrosh.constants</code>","text":"<p>Universal gas constant [J/kmol/K].</p>"},{"location":"reference/errors/","title":"<code>rgfrosh.errors</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the iterative solver fails to converge.</p> Source code in <code>rgfrosh\\errors.py</code> <pre><code>class ConvergenceError(Exception):\n    \"\"\"\n    Exception raised when the iterative solver fails to converge.\n    \"\"\"\n</code></pre>"},{"location":"reference/thermo/","title":"<code>rgfrosh.thermo</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class defining the required interface for calculating mixture thermodynamic properties.</p> Source code in <code>rgfrosh\\thermo.py</code> <pre><code>class ThermoInterface(Protocol):\n    \"\"\"\n    Class defining the required interface for calculating mixture thermodynamic\n    properties.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def TP(self) -&gt; Tuple[float, float]:\n        \"\"\"Get/set temperature [K] and pressure [Pa].\"\"\"\n\n    @TP.setter\n    @abstractmethod\n    def TP(self, value: Tuple[float, float]):\n        \"\"\"Get/set temperature [K] and pressure [Pa].\"\"\"\n\n    @property\n    @abstractmethod\n    def mean_molecular_weight(self) -&gt; float:\n        \"\"\"The mean molecular weight (molar mass) [kg/kmol].\"\"\"\n\n    @property\n    @abstractmethod\n    def density_mass(self) -&gt; float:\n        \"\"\"(Mass) density [kg/m^3^].\"\"\"\n\n    @property\n    @abstractmethod\n    def cp_mass(self) -&gt; float:\n        \"\"\"Specific heat capacity at constant pressure [J/kg/K].\"\"\"\n\n    @property\n    @abstractmethod\n    def enthalpy_mass(self) -&gt; float:\n        \"\"\"Specific enthalpy [J/kg].\"\"\"\n\n    @property\n    @abstractmethod\n    def isothermal_compressibility(self) -&gt; float:\n        \"\"\"Isothermal compressibility [1/Pa].\"\"\"\n\n    @property\n    @abstractmethod\n    def thermal_expansion_coeff(self) -&gt; float:\n        \"\"\"Thermal expansion coefficient [1/K].\"\"\"\n</code></pre> <p>               Bases: <code>ThermoInterface</code></p> <p> 0.1.4</p> <p>Note</p> <p>Only available if <code>CoolProp</code> is installed.</p> <p>Wrapper for <code>CoolProp.AbstractState</code> objects that accounts for differing property names and automatically adjusts units for <code>mean_molecular_weight</code>.</p> Source code in <code>rgfrosh\\thermo.py</code> <pre><code>class CPInterface(ThermoInterface):\n    \"\"\"\n    :octicons-tag-24: 0.1.4\n\n    !!! Note\n        Only available if `CoolProp` is installed.\n\n    Wrapper for `CoolProp.AbstractState` objects that accounts for\n    differing property names and automatically adjusts units for\n    `mean_molecular_weight`.\n    \"\"\"\n\n    def __init__(self, state: CP.AbstractState):\n        self.state = state\n\n    @property\n    def mean_molecular_weight(self):\n        return self.state.molar_mass() * 1e3  # [kg/mol] to [kg/kmol]\n\n    @property\n    def TP(self):\n        return self.state.T(), self.state.p()\n\n    @TP.setter\n    def TP(self, value):\n        T, P = value\n        self.state.update(CP.PT_INPUTS, P, T)\n\n    @property\n    def density_mass(self):\n        return self.state.rhomass()\n\n    @property\n    def cp_mass(self):\n        return self.state.cpmass()\n\n    @property\n    def enthalpy_mass(self):\n        return self.state.hmass()\n\n    @property\n    def isothermal_compressibility(self):\n        return self.state.isothermal_compressibility()\n\n    @property\n    def thermal_expansion_coeff(self):\n        return self.state.isobaric_expansion_coefficient()\n</code></pre>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.TP","title":"<code>TP: Tuple[float, float]</code>  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<p>Get/set temperature [K] and pressure [Pa].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.cp_mass","title":"<code>cp_mass: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Specific heat capacity at constant pressure [J/kg/K].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.density_mass","title":"<code>density_mass: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>(Mass) density [kg/m<sup>3</sup>].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.enthalpy_mass","title":"<code>enthalpy_mass: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Specific enthalpy [J/kg].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.isothermal_compressibility","title":"<code>isothermal_compressibility: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Isothermal compressibility [1/Pa].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.mean_molecular_weight","title":"<code>mean_molecular_weight: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The mean molecular weight (molar mass) [kg/kmol].</p>"},{"location":"reference/thermo/#rgfrosh.thermo.ThermoInterface.thermal_expansion_coeff","title":"<code>thermal_expansion_coeff: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Thermal expansion coefficient [1/K].</p>"},{"location":"reference/shock/","title":"<code>rgfrosh.shock</code>","text":"<p>The core functionality of <code>rgfrosh</code> is built on the <code>Shock</code> class, which defines the state of the different regions of the reflected shock. <code>Shock</code> is a frozen data class - its attributes cannot be assigned after  instantiation - and thus it is not very useful to instantiate it directly. Two different models are defined to calculate shock conditions: </p> <ul> <li>Ideal shock - the analytical solution of the conservation equations    for ideal (calorically perfect) gases.</li> <li>Frozen shock - a numerical solver for a gas with an arbitrary equation of state.</li> </ul> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@frozen\nclass Shock:\n    u1: float\n    \"\"\"Incident shock velocity [m/s].\"\"\"\n    T1: float\n    \"\"\"Initial temperature [K].\"\"\"\n    P1: float\n    \"\"\"Initial pressure [Pa].\"\"\"\n    rho1: float\n    \"\"\"Initial density [kg/m^3^].\"\"\"\n\n    u2: float\n    \"\"\"Velocity behind the incident shock (shock-fixed) [m/s].\"\"\"\n    T2: float\n    \"\"\"Temperature behind the incident shock [K].\"\"\"\n    P2: float\n    \"\"\"Pressure behind the incident shock [Pa].\"\"\"\n    rho2: float\n    \"\"\"Density behind the incident shock [kg/m^3^].\"\"\"\n\n    u5: float\n    \"\"\"Reflected shock velocity [m/s].\"\"\"\n    T5: float\n    \"\"\"Temperature behind the reflected shock [K].\"\"\"\n    P5: float\n    \"\"\"Pressure behind the reflected shock [Pa].\"\"\"\n    rho5: float\n    \"\"\"Density behind the reflected shock [kg/m^3^].\"\"\"\n\n    MW: float\n    \"\"\"Mean molecular weight [kg/kmol].\"\"\"\n</code></pre>"},{"location":"reference/shock/#rgfrosh.shock.Shock.MW","title":"<code>MW: float</code>  <code>instance-attribute</code>","text":"<p>Mean molecular weight [kg/kmol].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.P1","title":"<code>P1: float</code>  <code>instance-attribute</code>","text":"<p>Initial pressure [Pa].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.P2","title":"<code>P2: float</code>  <code>instance-attribute</code>","text":"<p>Pressure behind the incident shock [Pa].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.P5","title":"<code>P5: float</code>  <code>instance-attribute</code>","text":"<p>Pressure behind the reflected shock [Pa].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.T1","title":"<code>T1: float</code>  <code>instance-attribute</code>","text":"<p>Initial temperature [K].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.T2","title":"<code>T2: float</code>  <code>instance-attribute</code>","text":"<p>Temperature behind the incident shock [K].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.T5","title":"<code>T5: float</code>  <code>instance-attribute</code>","text":"<p>Temperature behind the reflected shock [K].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.rho1","title":"<code>rho1: float</code>  <code>instance-attribute</code>","text":"<p>Initial density [kg/m<sup>3</sup>].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.rho2","title":"<code>rho2: float</code>  <code>instance-attribute</code>","text":"<p>Density behind the incident shock [kg/m<sup>3</sup>].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.rho5","title":"<code>rho5: float</code>  <code>instance-attribute</code>","text":"<p>Density behind the reflected shock [kg/m<sup>3</sup>].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.u1","title":"<code>u1: float</code>  <code>instance-attribute</code>","text":"<p>Incident shock velocity [m/s].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.u2","title":"<code>u2: float</code>  <code>instance-attribute</code>","text":"<p>Velocity behind the incident shock (shock-fixed) [m/s].</p>"},{"location":"reference/shock/#rgfrosh.shock.Shock.u5","title":"<code>u5: float</code>  <code>instance-attribute</code>","text":"<p>Reflected shock velocity [m/s].</p>"},{"location":"reference/shock/frozen/","title":"<code>rgfrosh.shock.FrozenShock</code>","text":"<p>               Bases: <code>Shock</code></p> <p>A class for calculating properties in various regions of a reflected shock given the <code>ThermoInterface</code> for a mixture. The incident and reflected solver equations are from Davidson and Hanson<sup>1</sup>. The equations for the initial conditions solver were derived in the appendix of the cited dissertation<sup>2</sup>.</p> <ol> <li> <p>Davidson, D. F. and R. K. Hanson (1996). \"Real Gas Corrections in Shock Tube Studies at High Pressures.\" Israel Journal of Chemistry 36(3): 321-326.\u00a0\u21a9</p> </li> <li> <p>Kinney, Cory, \"Extreme-Pressure Ignition Studies of Methane and Natural Gas with CO2 with Applications in Rockets and Gas Turbines\" (2022). Electronic Theses and Dissertations, 2020-. 1033. https://stars.library.ucf.edu/etd2020/1033 \u21a9</p> </li> </ol> Source code in <code>rgfrosh\\shock.py</code> <pre><code>class FrozenShock(Shock):\n    \"\"\"\n    A class for calculating properties in various regions of a reflected shock given\n    the [`ThermoInterface`](../../thermo/#rgfrosh.thermo.ThermoInterface) for a mixture. The\n    [incident](rgfrosh.shock.FrozenShock.solve_incident) and\n    [reflected](rgfrosh.shock.FrozenShock.solve_reflected) solver equations are from Davidson and\n    Hanson[^1]. The equations for the\n    [initial conditions solver](rgfrosh.shock.FrozenShock.solve_initial) were derived in the appendix\n    of the cited dissertation[^2].\n\n    [^1]: Davidson, D. F. and R. K. Hanson (1996). \"Real Gas Corrections in Shock Tube Studies at\n    High Pressures.\" Israel Journal of Chemistry 36(3): 321-326.\n    [^2]: Kinney, Cory, \"Extreme-Pressure Ignition Studies of Methane and Natural Gas with CO2 with\n    Applications in Rockets and Gas Turbines\" (2022). Electronic Theses and Dissertations, 2020-. 1033.\n    [https://stars.library.ucf.edu/etd2020/1033](https://stars.library.ucf.edu/etd2020/1033)\n    \"\"\"\n\n    max_iter: int = 1000\n    \"\"\"Maximum number of iterations for the solver.\"\"\"\n\n    rtol: float = 1e-6\n    \"\"\"Relative tolerance for the solver convergence criteria.\"\"\"\n\n    def __init__(\n        self,\n        thermo: ThermoInterface,\n        *,\n        u1: float = None,\n        T1: float = 300,\n        P1: float = None,\n        T5: float = None,\n        P5: float = None,\n    ):\n        \"\"\"\n        Solves the frozen shock equations for the following combination of parameters:\n\n        1. Incident shock velocity ($u_1$) and initial conditions ($T_1$, $P_1$)\n        2. Reflected shock conditions ($T_5$, $P_5$) and initial temperature ($T_1$)\n\n        Arguments:\n            thermo: Thermodynamic interface.\n\n        Keyword arguments:\n            u1: Incident shock velocity [m/s].\n            T1: Initial temperature [K].\n            P1: Initial pressure [Pa].\n            T5: Temperature behind the reflected shock [K].\n            P5: Pressure behind the reflected shock [Pa].\n\n        Raises:\n            ValueError: If the system is underconstrained/overconstrained.\n        \"\"\"\n\n        MW = thermo.mean_molecular_weight\n\n        if u1 and T1 and P1:\n            if T5 or P5:\n                raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n            thermo.TP = T1, P1\n            rho1 = thermo.density_mass\n\n            u2, T2, P2, rho2 = FrozenShock.solve_incident(thermo, u1, T1, P1)\n            u5, T5, P5, rho5 = FrozenShock.solve_reflected(thermo, u1, P1, u2, T2, P2)\n\n        elif T5 and P5 and T1:\n            if P1 or u1:\n                raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n            u1, P1, u2, T2, P2, u5 = FrozenShock.solve_initial(thermo, T5, P5, T1)\n\n            thermo.TP = T1, P1\n            rho1 = thermo.density_mass\n            thermo.TP = T2, P2\n            rho2 = thermo.density_mass\n            thermo.TP = T5, P5\n            rho5 = thermo.density_mass\n\n        else:\n            raise ValueError(\"Underconstrained - insufficient arguments provided.\")\n\n        super().__init__(u1, T1, P1, rho1, u2, T2, P2, rho2, u5, T5, P5, rho5, MW)\n\n    @property\n    def Z(self):\n        \"\"\"\n        Compressibility factor ($Z$) at the reflected shock conditions.\n\n        !!! New \"New in `v0.2.0`\"\n        \"\"\"\n        return self.P5 / (self.rho5 * GAS_CONSTANT / self.MW * self.T5)\n\n    @staticmethod\n    def solve_incident(\n        thermo: ThermoInterface,\n        u1: float,\n        T1: float,\n        P1: float,\n    ) -&gt; Tuple[float, float, float, float]:\n        \"\"\"\n        Solves for the conditions behind the incident shock.\n\n        Parameters:\n            thermo: Thermodynamic interface.\n            u1: Incident shock velocity [m/s].\n            T1: Initial temperature [K].\n            P1: Initial pressure [Pa].\n\n        Returns:\n            u2: Velocity behind the incident shock (shock-fixed) [m/s].\n            T2: Temperature behind the incident shock [K].\n            P2: Pressure behind the incident shock [Pa].\n            rho2: Density behind the incident shock [kg/m^3^].\n\n        Exceptions:\n            ConvergenceError: If the relative change in `T5` and `P5` is not below the\n                [`rtol`][rgfrosh.shock.FrozenShock.rtol] within\n                [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n        \"\"\"\n\n        thermo.TP = T1, P1\n        h1 = thermo.enthalpy_mass\n        nu1 = 1 / thermo.density_mass\n        cp1 = thermo.cp_mass\n\n        R = GAS_CONSTANT / thermo.mean_molecular_weight\n        gamma1 = cp1 / (cp1 - R)\n\n        # Calculate an initial guess of P2 and T2 with the ideal gas assumption\n        M1 = u1 / (gamma1 * R * T1) ** 0.5\n        T2 = T1 * (\n            (gamma1 * M1**2 - (gamma1 - 1) / 2)\n            * ((gamma1 - 1) / 2 * M1**2 + 1)\n            / ((gamma1 + 1) / 2 * M1) ** 2\n        )\n        P2 = P1 * (2 * gamma1 * M1**2 - (gamma1 - 1)) / (gamma1 + 1)\n\n        for i in range(FrozenShock.max_iter):\n            # Calculate thermodynamic properties at T2, P2 guess\n            thermo.TP = T2, P2\n            h2 = thermo.enthalpy_mass\n            nu2 = 1 / thermo.density_mass\n            cp2 = thermo.cp_mass\n            beta2 = thermo.thermal_expansion_coeff\n            kappa2 = thermo.isothermal_compressibility\n\n            f1 = (P2 / P1 - 1) + (u1**2 / (P1 * nu1)) * (nu2 / nu1 - 1)\n            f2 = ((h2 - h1) / (1 / 2 * u1**2)) + (nu2**2 / nu1**2 - 1)\n\n            df1_dT2 = u1**2 * nu2 * beta2 / (P1 * nu1**2)\n            df1_dP2 = 1 / P1 - u1**2 * nu2 * kappa2 / (P1 * nu1**2)\n\n            df2_dT2 = 2 * cp2 / u1**2 + 2 * (nu2 / nu1) ** 2 * beta2\n            df2_dP2 = (\n                2 * nu2 * (1 - T2 * beta2) / u1**2 - 2 * nu2**2 * kappa2 / nu1**2\n            )\n\n            deltaT2, deltaP2 = np.matmul(\n                np.linalg.inv(np.array([[df1_dT2, df1_dP2], [df2_dT2, df2_dP2]])),\n                np.array([f1, f2]),\n            )\n\n            converged = (\n                abs(deltaT2) &lt;= T2 * FrozenShock.rtol\n                and abs(deltaP2) &lt;= P2 * FrozenShock.rtol\n            )\n\n            T2 -= deltaT2\n            P2 -= deltaP2\n\n            if converged:\n                thermo.TP = T2, P2\n                nu2 = 1 / thermo.density_mass\n                u2 = u1 * nu2 / nu1\n                return u2, T2, P2, thermo.density_mass\n\n        raise ConvergenceError\n\n    @staticmethod\n    def solve_reflected(\n        thermo: ThermoInterface,\n        u1: float,\n        P1: float,\n        u2: float,\n        T2: float,\n        P2: float,\n    ) -&gt; Tuple[float, float, float, float]:\n        \"\"\"\n        Solves for the conditions behind the reflected shock.\n\n        Parameters:\n            thermo: Thermodynamic interface.\n            u1: Incident shock velocity [m/s].\n            P1: Initial pressure [Pa].\n            u2: Velocity behind the incident shock (shock-fixed) [m/s].\n            T2: Temperature behind the incident shock [K].\n            P2: Pressure behind the incident shock [Pa].\n\n        Returns:\n            u5: Reflected shock velocity [m/s].\n            T5: Temperature behind the reflected shock [K].\n            P5: Pressure behind the reflected shock [Pa].\n            rho5: Density behind the reflected shock [kg/m^3^].\n\n        Exceptions:\n            ConvergenceError: If the relative change in `T5` and `P5` is not below the\n                [`rtol`][rgfrosh.shock.FrozenShock.rtol] within\n                [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n        \"\"\"\n\n        thermo.TP = T2, P2\n        h2 = thermo.enthalpy_mass\n        nu2 = 1 / thermo.density_mass\n\n        # Calculate an initial guess of P5 and T5 with the ideal gas assumption\n        cp2 = thermo.cp_mass\n        R = GAS_CONSTANT / thermo.mean_molecular_weight\n        gamma2 = cp2 / (cp2 - R)\n\n        eta2 = (gamma2 + 1) / (gamma2 - 1)\n        P5 = P2 * (eta2 + 2 - P1 / P2) / (1 + eta2 * P1 / P2)\n        T5 = T2 * P5 / P2 * (eta2 + P5 / P2) / (1 + eta2 * P5 / P2)\n\n        for i in range(FrozenShock.max_iter):\n            thermo.TP = T5, P5\n\n            h5 = thermo.enthalpy_mass\n            nu5 = 1 / thermo.density_mass\n            cp5 = thermo.cp_mass\n            beta5 = thermo.thermal_expansion_coeff\n            kappa5 = thermo.isothermal_compressibility\n\n            f3 = (P5 / P2 - 1) + (u1 - u2) ** 2 / P2 / (nu5 - nu2)\n            f4 = 2 * (h5 - h2) / (u1 - u2) ** 2 + (nu5 + nu2) / (nu5 - nu2)\n\n            df3_dT5 = -nu5 * beta5 * (u1 - u2) ** 2 / (P2 * (nu5 - nu2) ** 2)\n            df3_dP5 = 1 / P2 + nu5 * kappa5 * (u1 - u2) ** 2 / (P2 * (nu5 - nu2) ** 2)\n\n            df4_dT5 = (\n                2 * cp5 / (u1 - u2) ** 2 - 2 * nu2 * nu5 * beta5 / (nu5 - nu2) ** 2\n            )\n            df4_dP5 = (\n                2 * nu5 * (1 - T5 * beta5) / (u1 - u2) ** 2\n                + 2 * nu2 * nu5 * kappa5 / (nu5 - nu2) ** 2\n            )\n\n            deltaT5, deltaP5 = np.matmul(\n                np.linalg.inv(np.array([[df3_dT5, df3_dP5], [df4_dT5, df4_dP5]])),\n                np.array([f3, f4]),\n            )\n\n            converged = (\n                abs(deltaT5) &lt;= T5 * FrozenShock.rtol\n                and abs(deltaP5) &lt;= P5 * FrozenShock.rtol\n            )\n\n            T5 -= deltaT5\n            P5 -= deltaP5\n\n            if converged:\n                thermo.TP = T5, P5\n                nu5 = 1 / thermo.density_mass\n                u5 = (u1 - u2) / (nu2 / nu5 - 1)\n                return u5, T5, P5, thermo.density_mass\n\n        raise ConvergenceError\n\n    @staticmethod\n    def solve_initial(thermo: ThermoInterface, T5: float, P5: float, T1: float = 300):\n        \"\"\"\n        Solves for the initial pressure and incident shock velocity given the target\n        post-reflected-shock conditions.\n\n        Parameters:\n            thermo: Thermodynamic interface.\n            T5: Temperature behind the reflected shock [K].\n            P5: Pressure behind the reflected shock [Pa].\n            T1: Initial temperature [K].\n\n        Exceptions:\n            ConvergenceError: If the relative change in `u1`, `P1`, `T2`, and `P2`\n                is not below the [`rtol`][rgfrosh.shock.FrozenShock.rtol]\n                within [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n        \"\"\"\n\n        thermo.TP = T5, P5\n        h5 = thermo.enthalpy_mass\n        nu5 = 1 / thermo.density_mass\n\n        thermo.TP = T1, 101325\n        cp1 = thermo.cp_mass\n        R = GAS_CONSTANT / thermo.mean_molecular_weight\n        gamma1 = cp1 / (cp1 - R)\n        a1 = (gamma1 * GAS_CONSTANT / thermo.mean_molecular_weight * T1) ** 0.5\n\n        MS = IdealShock.incident_Mach_number(gamma1, T5, T1)\n        P1 = P5 / IdealShock.reflected_pressure_ratio(MS, gamma1)\n        P2 = P1 * IdealShock.incident_pressure_ratio(MS, gamma1)\n        T2 = T1 * IdealShock.incident_temperature_ratio(MS, gamma1)\n\n        u1 = MS * a1\n\n        for i in range(FrozenShock.max_iter):\n            thermo.TP = T1, P1\n            h1 = thermo.enthalpy_mass\n            nu1 = 1 / thermo.density_mass\n            beta1 = thermo.thermal_expansion_coeff\n            kappa1 = thermo.isothermal_compressibility\n\n            thermo.TP = T2, P2\n            h2 = thermo.enthalpy_mass\n            nu2 = 1 / thermo.density_mass\n            cp2 = thermo.cp_mass\n            beta2 = thermo.thermal_expansion_coeff\n            kappa2 = thermo.isothermal_compressibility\n\n            f1 = P2 / P1 - 1 + u1**2 / (P1 * nu1) * (nu2 / nu1 - 1)\n            f2 = 2 * (h2 - h1) / u1**2 + (nu2 / nu1) ** 2 - 1\n            f3 = (P5 / P2 - 1) + (u1 * (1 - nu2 / nu1)) ** 2 / P2 / (nu5 - nu2)\n            f4 = 2 * (h5 - h2) / (u1 * (1 - nu2 / nu1)) ** 2 + (nu5 + nu2) / (nu5 - nu2)\n\n            df1_du1 = 2 * u1 / (P1 * nu1**2) * (nu2 - nu1)\n            df1_dP1 = -P2 / P1**2 + u1**2 / (P1**2 * nu1**2) * (\n                P1 * kappa1 * (2 * nu2 - nu1) - (nu2 - nu1)\n            )\n            df1_dT2 = u1**2 * nu2 * beta2 / (P1 * nu1**2)\n            df1_dP2 = 1 / P1 - u1**2 * nu2 * kappa2 / (P1 * nu1**2)\n\n            df2_du1 = -4 * (h2 - h1) / u1**3\n            df2_dP1 = (\n                2 * nu2**2 * kappa1 / nu1**2 - 2 * nu1 * (1 - T1 * beta1) / u1**2\n            )\n            df2_dT2 = 2 * cp2 / u1**2 + 2 * (nu2 / nu1) ** 2 * beta2\n            df2_dP2 = (\n                2 * nu2 * (1 - T2 * beta2) / u1**2 - 2 * nu2**2 * kappa2 / nu1**2\n            )\n\n            df3_du1 = 2 * u1 * (1 - nu2 / nu1) ** 2 / (P2 * (nu5 - nu2))\n            df3_dP2 = -P5 / P2**2 - (\n                u1**2 / (nu1**2 * P2) * (nu1 - nu2) / (nu5 - nu2)\n            ) * (nu2 * kappa2 * (nu1 + nu2 - 2 * nu5) / (nu5 - nu2) + (nu1 - nu2) / P2)\n\n            df3_dT2 = (\n                (u1**2 * nu2 * beta2)\n                / (P2 * nu1**2)\n                * (nu1 - nu2)\n                / (nu5 - nu2) ** 2\n                * (nu1 + nu2 - 2 * nu5)\n            )\n            df4_dT2 = (2 * nu1**2 / u1**2) * (\n                2 * nu2 * beta2 * (h5 - h2) - cp2 * (nu1 - nu2)\n            ) / (nu1 - nu2) ** 3 + 2 * nu2 * nu5 * beta2 / (nu5 - nu2) ** 2\n            df4_dP2 = (-2 * nu1**2 * nu2) / u1**2 * (\n                2 * kappa2 * (h5 - h2) + (nu1 - nu2) * (1 - T2 * beta2)\n            ) / (nu1 - nu2) ** 3 - 2 * nu2 * nu5 * kappa2 / (nu5 - nu2) ** 2\n            df3_dP1 = (\n                -2 * u1**2 * nu2 * kappa1 * (1 - nu2 / nu1) / (P2 * nu1 * (nu5 - nu2))\n            )\n            df4_du1 = -4 * (h5 - h2) / (u1**3 * (1 - nu2 / nu1) ** 2)\n            df4_dP1 = (\n                4 * nu2 * kappa1 * (h5 - h2) / (u1**2 * nu1) / (1 - nu2 / nu1) ** 3\n            )\n\n            delta_u1, delta_P1, delta_T2, delta_P2 = np.matmul(\n                np.linalg.inv(\n                    np.array(\n                        [\n                            [df1_du1, df1_dP1, df1_dT2, df1_dP2],\n                            [df2_du1, df2_dP1, df2_dT2, df2_dP2],\n                            [df3_du1, df3_dP1, df3_dT2, df3_dP2],\n                            [df4_du1, df4_dP1, df4_dT2, df4_dP2],\n                        ]\n                    )\n                ),\n                np.array([f1, f2, f3, f4]),\n            )\n\n            converged = (\n                abs(delta_u1) &lt;= u1 * FrozenShock.rtol\n                and abs(delta_P1) &lt;= P1 * FrozenShock.rtol\n                and abs(delta_T2) &lt;= T2 * FrozenShock.rtol\n                and abs(delta_P2) &lt;= P2 * FrozenShock.rtol\n            )\n\n            u1 -= delta_u1\n            P1 -= delta_P1\n            T2 -= delta_T2\n            P2 -= delta_P2\n\n            if converged:\n                thermo.TP = T1, P1\n                rho1 = thermo.density_mass\n                thermo.TP = T2, P2\n                rho2 = thermo.density_mass\n\n                u2 = u1 * rho1 / rho2\n                u5 = (u1 - u2) / (nu2 / nu5 - 1)\n\n                return u1, P1, u2, T2, P2, u5\n\n        raise ConvergenceError\n</code></pre>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.Z","title":"<code>Z</code>  <code>property</code>","text":"<p>Compressibility factor (\\(Z\\)) at the reflected shock conditions.</p> <p>New in <code>v0.2.0</code></p>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.max_iter","title":"<code>max_iter: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of iterations for the solver.</p>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.rtol","title":"<code>rtol: float = 1e-06</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Relative tolerance for the solver convergence criteria.</p>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.__init__","title":"<code>__init__(thermo, *, u1=None, T1=300, P1=None, T5=None, P5=None)</code>","text":"<p>Solves the frozen shock equations for the following combination of parameters:</p> <ol> <li>Incident shock velocity (\\(u_1\\)) and initial conditions (\\(T_1\\), \\(P_1\\))</li> <li>Reflected shock conditions (\\(T_5\\), \\(P_5\\)) and initial temperature (\\(T_1\\))</li> </ol> <p>Parameters:</p> Name Type Description Default <code>thermo</code> <code>ThermoInterface</code> <p>Thermodynamic interface.</p> required <p>Other Parameters:</p> Name Type Description <code>u1</code> <code>float</code> <p>Incident shock velocity [m/s].</p> <code>T1</code> <code>float</code> <p>Initial temperature [K].</p> <code>P1</code> <code>float</code> <p>Initial pressure [Pa].</p> <code>T5</code> <code>float</code> <p>Temperature behind the reflected shock [K].</p> <code>P5</code> <code>float</code> <p>Pressure behind the reflected shock [Pa].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the system is underconstrained/overconstrained.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>def __init__(\n    self,\n    thermo: ThermoInterface,\n    *,\n    u1: float = None,\n    T1: float = 300,\n    P1: float = None,\n    T5: float = None,\n    P5: float = None,\n):\n    \"\"\"\n    Solves the frozen shock equations for the following combination of parameters:\n\n    1. Incident shock velocity ($u_1$) and initial conditions ($T_1$, $P_1$)\n    2. Reflected shock conditions ($T_5$, $P_5$) and initial temperature ($T_1$)\n\n    Arguments:\n        thermo: Thermodynamic interface.\n\n    Keyword arguments:\n        u1: Incident shock velocity [m/s].\n        T1: Initial temperature [K].\n        P1: Initial pressure [Pa].\n        T5: Temperature behind the reflected shock [K].\n        P5: Pressure behind the reflected shock [Pa].\n\n    Raises:\n        ValueError: If the system is underconstrained/overconstrained.\n    \"\"\"\n\n    MW = thermo.mean_molecular_weight\n\n    if u1 and T1 and P1:\n        if T5 or P5:\n            raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n        thermo.TP = T1, P1\n        rho1 = thermo.density_mass\n\n        u2, T2, P2, rho2 = FrozenShock.solve_incident(thermo, u1, T1, P1)\n        u5, T5, P5, rho5 = FrozenShock.solve_reflected(thermo, u1, P1, u2, T2, P2)\n\n    elif T5 and P5 and T1:\n        if P1 or u1:\n            raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n        u1, P1, u2, T2, P2, u5 = FrozenShock.solve_initial(thermo, T5, P5, T1)\n\n        thermo.TP = T1, P1\n        rho1 = thermo.density_mass\n        thermo.TP = T2, P2\n        rho2 = thermo.density_mass\n        thermo.TP = T5, P5\n        rho5 = thermo.density_mass\n\n    else:\n        raise ValueError(\"Underconstrained - insufficient arguments provided.\")\n\n    super().__init__(u1, T1, P1, rho1, u2, T2, P2, rho2, u5, T5, P5, rho5, MW)\n</code></pre>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.solve_incident","title":"<code>solve_incident(thermo, u1, T1, P1)</code>  <code>staticmethod</code>","text":"<p>Solves for the conditions behind the incident shock.</p> <p>Parameters:</p> Name Type Description Default <code>thermo</code> <code>ThermoInterface</code> <p>Thermodynamic interface.</p> required <code>u1</code> <code>float</code> <p>Incident shock velocity [m/s].</p> required <code>T1</code> <code>float</code> <p>Initial temperature [K].</p> required <code>P1</code> <code>float</code> <p>Initial pressure [Pa].</p> required <p>Returns:</p> Name Type Description <code>u2</code> <code>float</code> <p>Velocity behind the incident shock (shock-fixed) [m/s].</p> <code>T2</code> <code>float</code> <p>Temperature behind the incident shock [K].</p> <code>P2</code> <code>float</code> <p>Pressure behind the incident shock [Pa].</p> <code>rho2</code> <code>float</code> <p>Density behind the incident shock [kg/m<sup>3</sup>].</p> <p>Raises:</p> Type Description <code>ConvergenceError</code> <p>If the relative change in <code>T5</code> and <code>P5</code> is not below the <code>rtol</code> within <code>max_iter</code> iterations.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef solve_incident(\n    thermo: ThermoInterface,\n    u1: float,\n    T1: float,\n    P1: float,\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Solves for the conditions behind the incident shock.\n\n    Parameters:\n        thermo: Thermodynamic interface.\n        u1: Incident shock velocity [m/s].\n        T1: Initial temperature [K].\n        P1: Initial pressure [Pa].\n\n    Returns:\n        u2: Velocity behind the incident shock (shock-fixed) [m/s].\n        T2: Temperature behind the incident shock [K].\n        P2: Pressure behind the incident shock [Pa].\n        rho2: Density behind the incident shock [kg/m^3^].\n\n    Exceptions:\n        ConvergenceError: If the relative change in `T5` and `P5` is not below the\n            [`rtol`][rgfrosh.shock.FrozenShock.rtol] within\n            [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n    \"\"\"\n\n    thermo.TP = T1, P1\n    h1 = thermo.enthalpy_mass\n    nu1 = 1 / thermo.density_mass\n    cp1 = thermo.cp_mass\n\n    R = GAS_CONSTANT / thermo.mean_molecular_weight\n    gamma1 = cp1 / (cp1 - R)\n\n    # Calculate an initial guess of P2 and T2 with the ideal gas assumption\n    M1 = u1 / (gamma1 * R * T1) ** 0.5\n    T2 = T1 * (\n        (gamma1 * M1**2 - (gamma1 - 1) / 2)\n        * ((gamma1 - 1) / 2 * M1**2 + 1)\n        / ((gamma1 + 1) / 2 * M1) ** 2\n    )\n    P2 = P1 * (2 * gamma1 * M1**2 - (gamma1 - 1)) / (gamma1 + 1)\n\n    for i in range(FrozenShock.max_iter):\n        # Calculate thermodynamic properties at T2, P2 guess\n        thermo.TP = T2, P2\n        h2 = thermo.enthalpy_mass\n        nu2 = 1 / thermo.density_mass\n        cp2 = thermo.cp_mass\n        beta2 = thermo.thermal_expansion_coeff\n        kappa2 = thermo.isothermal_compressibility\n\n        f1 = (P2 / P1 - 1) + (u1**2 / (P1 * nu1)) * (nu2 / nu1 - 1)\n        f2 = ((h2 - h1) / (1 / 2 * u1**2)) + (nu2**2 / nu1**2 - 1)\n\n        df1_dT2 = u1**2 * nu2 * beta2 / (P1 * nu1**2)\n        df1_dP2 = 1 / P1 - u1**2 * nu2 * kappa2 / (P1 * nu1**2)\n\n        df2_dT2 = 2 * cp2 / u1**2 + 2 * (nu2 / nu1) ** 2 * beta2\n        df2_dP2 = (\n            2 * nu2 * (1 - T2 * beta2) / u1**2 - 2 * nu2**2 * kappa2 / nu1**2\n        )\n\n        deltaT2, deltaP2 = np.matmul(\n            np.linalg.inv(np.array([[df1_dT2, df1_dP2], [df2_dT2, df2_dP2]])),\n            np.array([f1, f2]),\n        )\n\n        converged = (\n            abs(deltaT2) &lt;= T2 * FrozenShock.rtol\n            and abs(deltaP2) &lt;= P2 * FrozenShock.rtol\n        )\n\n        T2 -= deltaT2\n        P2 -= deltaP2\n\n        if converged:\n            thermo.TP = T2, P2\n            nu2 = 1 / thermo.density_mass\n            u2 = u1 * nu2 / nu1\n            return u2, T2, P2, thermo.density_mass\n\n    raise ConvergenceError\n</code></pre>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.solve_initial","title":"<code>solve_initial(thermo, T5, P5, T1=300)</code>  <code>staticmethod</code>","text":"<p>Solves for the initial pressure and incident shock velocity given the target post-reflected-shock conditions.</p> <p>Parameters:</p> Name Type Description Default <code>thermo</code> <code>ThermoInterface</code> <p>Thermodynamic interface.</p> required <code>T5</code> <code>float</code> <p>Temperature behind the reflected shock [K].</p> required <code>P5</code> <code>float</code> <p>Pressure behind the reflected shock [Pa].</p> required <code>T1</code> <code>float</code> <p>Initial temperature [K].</p> <code>300</code> <p>Raises:</p> Type Description <code>ConvergenceError</code> <p>If the relative change in <code>u1</code>, <code>P1</code>, <code>T2</code>, and <code>P2</code> is not below the <code>rtol</code> within <code>max_iter</code> iterations.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef solve_initial(thermo: ThermoInterface, T5: float, P5: float, T1: float = 300):\n    \"\"\"\n    Solves for the initial pressure and incident shock velocity given the target\n    post-reflected-shock conditions.\n\n    Parameters:\n        thermo: Thermodynamic interface.\n        T5: Temperature behind the reflected shock [K].\n        P5: Pressure behind the reflected shock [Pa].\n        T1: Initial temperature [K].\n\n    Exceptions:\n        ConvergenceError: If the relative change in `u1`, `P1`, `T2`, and `P2`\n            is not below the [`rtol`][rgfrosh.shock.FrozenShock.rtol]\n            within [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n    \"\"\"\n\n    thermo.TP = T5, P5\n    h5 = thermo.enthalpy_mass\n    nu5 = 1 / thermo.density_mass\n\n    thermo.TP = T1, 101325\n    cp1 = thermo.cp_mass\n    R = GAS_CONSTANT / thermo.mean_molecular_weight\n    gamma1 = cp1 / (cp1 - R)\n    a1 = (gamma1 * GAS_CONSTANT / thermo.mean_molecular_weight * T1) ** 0.5\n\n    MS = IdealShock.incident_Mach_number(gamma1, T5, T1)\n    P1 = P5 / IdealShock.reflected_pressure_ratio(MS, gamma1)\n    P2 = P1 * IdealShock.incident_pressure_ratio(MS, gamma1)\n    T2 = T1 * IdealShock.incident_temperature_ratio(MS, gamma1)\n\n    u1 = MS * a1\n\n    for i in range(FrozenShock.max_iter):\n        thermo.TP = T1, P1\n        h1 = thermo.enthalpy_mass\n        nu1 = 1 / thermo.density_mass\n        beta1 = thermo.thermal_expansion_coeff\n        kappa1 = thermo.isothermal_compressibility\n\n        thermo.TP = T2, P2\n        h2 = thermo.enthalpy_mass\n        nu2 = 1 / thermo.density_mass\n        cp2 = thermo.cp_mass\n        beta2 = thermo.thermal_expansion_coeff\n        kappa2 = thermo.isothermal_compressibility\n\n        f1 = P2 / P1 - 1 + u1**2 / (P1 * nu1) * (nu2 / nu1 - 1)\n        f2 = 2 * (h2 - h1) / u1**2 + (nu2 / nu1) ** 2 - 1\n        f3 = (P5 / P2 - 1) + (u1 * (1 - nu2 / nu1)) ** 2 / P2 / (nu5 - nu2)\n        f4 = 2 * (h5 - h2) / (u1 * (1 - nu2 / nu1)) ** 2 + (nu5 + nu2) / (nu5 - nu2)\n\n        df1_du1 = 2 * u1 / (P1 * nu1**2) * (nu2 - nu1)\n        df1_dP1 = -P2 / P1**2 + u1**2 / (P1**2 * nu1**2) * (\n            P1 * kappa1 * (2 * nu2 - nu1) - (nu2 - nu1)\n        )\n        df1_dT2 = u1**2 * nu2 * beta2 / (P1 * nu1**2)\n        df1_dP2 = 1 / P1 - u1**2 * nu2 * kappa2 / (P1 * nu1**2)\n\n        df2_du1 = -4 * (h2 - h1) / u1**3\n        df2_dP1 = (\n            2 * nu2**2 * kappa1 / nu1**2 - 2 * nu1 * (1 - T1 * beta1) / u1**2\n        )\n        df2_dT2 = 2 * cp2 / u1**2 + 2 * (nu2 / nu1) ** 2 * beta2\n        df2_dP2 = (\n            2 * nu2 * (1 - T2 * beta2) / u1**2 - 2 * nu2**2 * kappa2 / nu1**2\n        )\n\n        df3_du1 = 2 * u1 * (1 - nu2 / nu1) ** 2 / (P2 * (nu5 - nu2))\n        df3_dP2 = -P5 / P2**2 - (\n            u1**2 / (nu1**2 * P2) * (nu1 - nu2) / (nu5 - nu2)\n        ) * (nu2 * kappa2 * (nu1 + nu2 - 2 * nu5) / (nu5 - nu2) + (nu1 - nu2) / P2)\n\n        df3_dT2 = (\n            (u1**2 * nu2 * beta2)\n            / (P2 * nu1**2)\n            * (nu1 - nu2)\n            / (nu5 - nu2) ** 2\n            * (nu1 + nu2 - 2 * nu5)\n        )\n        df4_dT2 = (2 * nu1**2 / u1**2) * (\n            2 * nu2 * beta2 * (h5 - h2) - cp2 * (nu1 - nu2)\n        ) / (nu1 - nu2) ** 3 + 2 * nu2 * nu5 * beta2 / (nu5 - nu2) ** 2\n        df4_dP2 = (-2 * nu1**2 * nu2) / u1**2 * (\n            2 * kappa2 * (h5 - h2) + (nu1 - nu2) * (1 - T2 * beta2)\n        ) / (nu1 - nu2) ** 3 - 2 * nu2 * nu5 * kappa2 / (nu5 - nu2) ** 2\n        df3_dP1 = (\n            -2 * u1**2 * nu2 * kappa1 * (1 - nu2 / nu1) / (P2 * nu1 * (nu5 - nu2))\n        )\n        df4_du1 = -4 * (h5 - h2) / (u1**3 * (1 - nu2 / nu1) ** 2)\n        df4_dP1 = (\n            4 * nu2 * kappa1 * (h5 - h2) / (u1**2 * nu1) / (1 - nu2 / nu1) ** 3\n        )\n\n        delta_u1, delta_P1, delta_T2, delta_P2 = np.matmul(\n            np.linalg.inv(\n                np.array(\n                    [\n                        [df1_du1, df1_dP1, df1_dT2, df1_dP2],\n                        [df2_du1, df2_dP1, df2_dT2, df2_dP2],\n                        [df3_du1, df3_dP1, df3_dT2, df3_dP2],\n                        [df4_du1, df4_dP1, df4_dT2, df4_dP2],\n                    ]\n                )\n            ),\n            np.array([f1, f2, f3, f4]),\n        )\n\n        converged = (\n            abs(delta_u1) &lt;= u1 * FrozenShock.rtol\n            and abs(delta_P1) &lt;= P1 * FrozenShock.rtol\n            and abs(delta_T2) &lt;= T2 * FrozenShock.rtol\n            and abs(delta_P2) &lt;= P2 * FrozenShock.rtol\n        )\n\n        u1 -= delta_u1\n        P1 -= delta_P1\n        T2 -= delta_T2\n        P2 -= delta_P2\n\n        if converged:\n            thermo.TP = T1, P1\n            rho1 = thermo.density_mass\n            thermo.TP = T2, P2\n            rho2 = thermo.density_mass\n\n            u2 = u1 * rho1 / rho2\n            u5 = (u1 - u2) / (nu2 / nu5 - 1)\n\n            return u1, P1, u2, T2, P2, u5\n\n    raise ConvergenceError\n</code></pre>"},{"location":"reference/shock/frozen/#rgfrosh.shock.FrozenShock.solve_reflected","title":"<code>solve_reflected(thermo, u1, P1, u2, T2, P2)</code>  <code>staticmethod</code>","text":"<p>Solves for the conditions behind the reflected shock.</p> <p>Parameters:</p> Name Type Description Default <code>thermo</code> <code>ThermoInterface</code> <p>Thermodynamic interface.</p> required <code>u1</code> <code>float</code> <p>Incident shock velocity [m/s].</p> required <code>P1</code> <code>float</code> <p>Initial pressure [Pa].</p> required <code>u2</code> <code>float</code> <p>Velocity behind the incident shock (shock-fixed) [m/s].</p> required <code>T2</code> <code>float</code> <p>Temperature behind the incident shock [K].</p> required <code>P2</code> <code>float</code> <p>Pressure behind the incident shock [Pa].</p> required <p>Returns:</p> Name Type Description <code>u5</code> <code>float</code> <p>Reflected shock velocity [m/s].</p> <code>T5</code> <code>float</code> <p>Temperature behind the reflected shock [K].</p> <code>P5</code> <code>float</code> <p>Pressure behind the reflected shock [Pa].</p> <code>rho5</code> <code>float</code> <p>Density behind the reflected shock [kg/m<sup>3</sup>].</p> <p>Raises:</p> Type Description <code>ConvergenceError</code> <p>If the relative change in <code>T5</code> and <code>P5</code> is not below the <code>rtol</code> within <code>max_iter</code> iterations.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef solve_reflected(\n    thermo: ThermoInterface,\n    u1: float,\n    P1: float,\n    u2: float,\n    T2: float,\n    P2: float,\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Solves for the conditions behind the reflected shock.\n\n    Parameters:\n        thermo: Thermodynamic interface.\n        u1: Incident shock velocity [m/s].\n        P1: Initial pressure [Pa].\n        u2: Velocity behind the incident shock (shock-fixed) [m/s].\n        T2: Temperature behind the incident shock [K].\n        P2: Pressure behind the incident shock [Pa].\n\n    Returns:\n        u5: Reflected shock velocity [m/s].\n        T5: Temperature behind the reflected shock [K].\n        P5: Pressure behind the reflected shock [Pa].\n        rho5: Density behind the reflected shock [kg/m^3^].\n\n    Exceptions:\n        ConvergenceError: If the relative change in `T5` and `P5` is not below the\n            [`rtol`][rgfrosh.shock.FrozenShock.rtol] within\n            [`max_iter`][rgfrosh.shock.FrozenShock.max_iter] iterations.\n\n    \"\"\"\n\n    thermo.TP = T2, P2\n    h2 = thermo.enthalpy_mass\n    nu2 = 1 / thermo.density_mass\n\n    # Calculate an initial guess of P5 and T5 with the ideal gas assumption\n    cp2 = thermo.cp_mass\n    R = GAS_CONSTANT / thermo.mean_molecular_weight\n    gamma2 = cp2 / (cp2 - R)\n\n    eta2 = (gamma2 + 1) / (gamma2 - 1)\n    P5 = P2 * (eta2 + 2 - P1 / P2) / (1 + eta2 * P1 / P2)\n    T5 = T2 * P5 / P2 * (eta2 + P5 / P2) / (1 + eta2 * P5 / P2)\n\n    for i in range(FrozenShock.max_iter):\n        thermo.TP = T5, P5\n\n        h5 = thermo.enthalpy_mass\n        nu5 = 1 / thermo.density_mass\n        cp5 = thermo.cp_mass\n        beta5 = thermo.thermal_expansion_coeff\n        kappa5 = thermo.isothermal_compressibility\n\n        f3 = (P5 / P2 - 1) + (u1 - u2) ** 2 / P2 / (nu5 - nu2)\n        f4 = 2 * (h5 - h2) / (u1 - u2) ** 2 + (nu5 + nu2) / (nu5 - nu2)\n\n        df3_dT5 = -nu5 * beta5 * (u1 - u2) ** 2 / (P2 * (nu5 - nu2) ** 2)\n        df3_dP5 = 1 / P2 + nu5 * kappa5 * (u1 - u2) ** 2 / (P2 * (nu5 - nu2) ** 2)\n\n        df4_dT5 = (\n            2 * cp5 / (u1 - u2) ** 2 - 2 * nu2 * nu5 * beta5 / (nu5 - nu2) ** 2\n        )\n        df4_dP5 = (\n            2 * nu5 * (1 - T5 * beta5) / (u1 - u2) ** 2\n            + 2 * nu2 * nu5 * kappa5 / (nu5 - nu2) ** 2\n        )\n\n        deltaT5, deltaP5 = np.matmul(\n            np.linalg.inv(np.array([[df3_dT5, df3_dP5], [df4_dT5, df4_dP5]])),\n            np.array([f3, f4]),\n        )\n\n        converged = (\n            abs(deltaT5) &lt;= T5 * FrozenShock.rtol\n            and abs(deltaP5) &lt;= P5 * FrozenShock.rtol\n        )\n\n        T5 -= deltaT5\n        P5 -= deltaP5\n\n        if converged:\n            thermo.TP = T5, P5\n            nu5 = 1 / thermo.density_mass\n            u5 = (u1 - u2) / (nu2 / nu5 - 1)\n            return u5, T5, P5, thermo.density_mass\n\n    raise ConvergenceError\n</code></pre>"},{"location":"reference/shock/ideal/","title":"<code>rgfrosh.shock.IdealShock</code>","text":"<p>               Bases: <code>Shock</code></p> <p>A class for calculating properties in various regions of an ideal reflected shock. Most of the equations implemented were derived in Gaydon and Hurle<sup>1</sup>.</p> <p>New in <code>v0.2.0</code></p> <ol> <li> <p>Gaydon, A. G. and I. R. Hurle (1963). The shock tube in high-temperature chemical physics, Reinhold Publishing Corporation.\u00a0\u21a9</p> </li> </ol> Source code in <code>rgfrosh\\shock.py</code> <pre><code>class IdealShock(Shock):\n    \"\"\"\n    A class for calculating properties in various regions of an ideal reflected shock. Most of\n    the equations implemented were derived in Gaydon and Hurle[^1].\n\n    !!! New \"New in `v0.2.0`\"\n\n    [^1]: Gaydon, A. G. and I. R. Hurle (1963). The shock tube in high-temperature chemical\n    physics, Reinhold Publishing Corporation.\n    \"\"\"\n\n    def __init__(\n        self,\n        gamma: float,\n        MW: float,\n        *,\n        M: float = None,\n        u1: float = None,\n        T1: float = 300,\n        P1: float = None,\n        T5: float = None,\n        P5: float = None,\n    ):\n        r\"\"\"\n        Solves the ideal shock equations for the following combination of parameters:\n\n        1. Incident shock Mach number ($M$), or incident shock velocity ($u_1$), and initial conditions ($T_1$, $P_1$)\n        2. Reflected shock conditions ($T_5$, $P_5$) and initial temperature ($T_1$)\n\n        given the mixture's specific heat ratio ($\\gamma$) and mean molecular weight ($\\overline{M}$).\n        Density is calculated using the ideal gas law:\n\n        $$\n        \\rho = \\frac{P}{RT}\n        $$\n\n        where $R$ is the specific gas constant:\n\n        $$\n        R = R_\\text{universal}/\\overline{M}\n        $$\n\n        The speed of sound ($a$) is calculated as:\n\n        $$\n        a = \\sqrt{\\gamma R T}\n        $$\n\n        Arguments:\n            gamma: Specific heat ratio.\n            MW: Molecular weight [g/mol].\n\n        Keyword arguments:\n            u1: Incident shock velocity [m/s].\n            M: Incident shock Mach number.\n            T1: Initial temperature [K].\n            P1: Initial pressure [Pa].\n            T5: Temperature behind the reflected shock [K].\n            P5: Pressure behind the reflected shock [Pa].\n\n        Raises:\n            ValueError: If the system is underconstrained/overconstrained.\n\n        \"\"\"\n\n        R = GAS_CONSTANT / MW\n        a1 = (gamma * R * T1) ** 0.5\n\n        if (M and T1 and P1) or (u1 and T1 and P1):\n            if (M and u1) or T5 or P5:\n                raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n            if M:\n                u1 = M * a1\n            else:\n                M = u1 / a1\n\n            P5 = P1 * IdealShock.reflected_pressure_ratio(M, gamma)\n            T5 = T1 * IdealShock.reflected_temperature_ratio(M, gamma)\n\n        elif T5 and P5 and T1:\n            if P1 or M or u1:\n                raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n            M = IdealShock.incident_Mach_number(gamma, T5, T1)\n            u1 = M * a1\n            P1 = P5 / IdealShock.reflected_pressure_ratio(M, gamma)\n\n        else:\n            raise ValueError(\"Underconstrained - insufficient arguments provided.\")\n\n        P2 = P1 * IdealShock.incident_pressure_ratio(M, gamma)\n        T2 = T1 * IdealShock.incident_temperature_ratio(M, gamma)\n\n        rho1 = P1 / (R * T1)\n        rho2 = P2 / (R * T2)\n        rho5 = P5 / (R * T5)\n\n        u2 = u1 / IdealShock.incident_density_ratio(M, gamma)\n        u5 = u1 * IdealShock.reflected_velocity_ratio(M, gamma)\n\n        super().__init__(u1, T1, P1, rho1, u2, T2, P2, rho2, u5, T5, P5, rho5, MW)\n\n    @classmethod\n    def from_thermo(cls, thermo: ThermoInterface, **kwargs):\n        r\"\"\"\n        Alternative constructor from a `ThermoInterface` object.\n\n        For an ideal gas, the specific heat at constant volume ($c_v$) is related to the specific heat\n        at constant pressure ($c_p$) by the gas constant ($R$):\n\n        $$\n        c_p = c_v + R\n        $$\n\n        therefore, the specific heat ratio ($\\gamma$) is calculated from the available properties as:\n\n        $$\n        \\gamma = \\frac{c_p}{c_p - R}\n        $$\n\n        !!! Note\n            $c_p$ is evaluated at the current state of the `thermo` object; therefore, the\n            calculated $\\gamma$ may differ from the nominal value.\n        \"\"\"\n        gamma = thermo.cp_mass / (\n            thermo.cp_mass - GAS_CONSTANT / thermo.mean_molecular_weight\n        )\n        return cls(gamma, thermo.mean_molecular_weight, **kwargs)\n\n    @staticmethod\n    def incident_pressure_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the pressure ratio across the incident shock:\n\n        $$\n        \\frac{P_2}{P_1} = \\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1}\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        return (2 * gamma * M**2 - (gamma - 1)) / (gamma + 1)\n\n    @staticmethod\n    def incident_temperature_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the temperature ratio across the incident shock:\n\n        $$\n        \\frac{T_2}{T_1} = \\frac{\n            \\left(\\gamma M^2 - \\frac{\\gamma-1}{2}\\right)\n            \\left(\\frac{\\gamma-1}{2}M^2+1\\right)\n        }{\n            \\left(\\frac{\\gamma+1}{2}\\right)^2 M^2\n        }\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        return (\n            (gamma * M**2 - (gamma - 1) / 2)\n            * ((gamma - 1) / 2 * M**2 + 1)\n            / ((gamma + 1) / 2 * M) ** 2\n        )\n\n    @staticmethod\n    def incident_density_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the density ratio across the incident shock:\n\n        $$\n        \\frac{\\rho_2}{\\rho_1} = \\frac {(\\gamma+1)M^2} {(\\gamma-1)M^2+2}\n        $$\n\n        which is also the velocity ratio across the incident shock:\n\n        $$\n        \\frac{u_1}{u_2} = \\frac{\\rho_2}{\\rho_1}\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        return (gamma + 1) * M**2 / ((gamma - 1) * M**2 + 2)\n\n    @staticmethod\n    def reflected_pressure_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the ratio of the reflected shock pressure to the initial pressure:\n\n        $$\n        \\frac{P_5}{P_1} = \\left[\\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1}\\right]\n        \\left[\\frac{(3\\gamma-1)M^2-2(\\gamma-1)}{(\\gamma-1)M^2+2}\\right]\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        return (\n            (2 * gamma * M**2 - (gamma - 1))\n            / (gamma + 1)\n            * ((3 * gamma - 1) * M**2 - 2 * (gamma - 1))\n            / ((gamma - 1) * M**2 + 2)\n        )\n\n    @staticmethod\n    def reflected_temperature_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the ratio of the reflected shock temperature to the initial temperature:\n\n        $$\n        \\frac{T_5}{T_1} = \\frac{\\left[2(\\gamma-1)M^2+(3-\\gamma)\\right]\n        \\left[(3\\gamma-1)M^2-2(\\gamma-1)\\right]}\n        {(\\gamma+1)^2M^2}\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        return (\n            (2 * (gamma - 1) * M**2 + 3 - gamma)\n            * ((3 * gamma - 1) * M**2 - 2 * (gamma - 1))\n            / ((gamma + 1) * M) ** 2\n        )\n\n    @staticmethod\n    def reflected_velocity_ratio(M: float, gamma: float) -&gt; float:\n        r\"\"\"\n        Calculates the ratio of the reflected shock velocity to the incident shock velocity:\n\n        $$\n        \\frac{V_R}{V_S} = \\frac{2+\\frac{2}{\\gamma-1}\\frac{P_1}{P_2}}\n        {\\frac{\\gamma+1}{\\gamma-1}-\\frac{P_1}{P_2}}\n        $$\n\n        Parameters:\n            M: Incident shock Mach number.\n            gamma: Specific heat ratio.\n        \"\"\"\n        P12 = 1 / IdealShock.incident_pressure_ratio(M, gamma)\n        return (2 + 2 * P12 / (gamma - 1)) / ((gamma + 1) / (gamma - 1) - P12)\n\n    @staticmethod\n    def incident_Mach_number(gamma: float, T5: float, T1: float = 1):\n        r\"\"\"\n        Calculates the incident shock Mach number from the ratio of the reflected shock\n        temperature to the initial temperature. Expanding the equation for the reflected temperature\n        ratio yields an equation of the form:\n\n        $$\n        aM^4 + bM^2 + c = 0\n        $$\n\n        where\n\n        $$\n        a = 2(3\\gamma-1)(\\gamma-1)\n        $$\n\n        $$\n        b = (3\\gamma-1)(3-\\gamma) - 4(\\gamma-1)^2 - \\frac{T_5}{T_1}(\\gamma+1)^2\n        $$\n\n        $$\n        c = -2(3-\\gamma)(\\gamma-1)\n        $$\n\n        Solving the above equation for $M^2$ using the quadratic formula, then taking the square\n        root of the non-negative solution, yields the incident shock Mach number for the given\n        temperature ratio:\n\n        $$\n        M = \\sqrt{\\frac{-b + \\sqrt{b^2-4ac}}{2a}}\n        $$\n\n        Parameters:\n            gamma: Specific heat ratio.\n            T5: Reflected shock temperature [K].\n            T1: Initial temperature [K].\n\n        !!! Note\n            If `T1` is not specified, it is assumed that the temperature ratio ${T_5}/{T_1}$ is given as `T5`.\n\n        \"\"\"\n        a = 2 * (gamma - 1) * (3 * gamma - 1)\n        b = (\n            (3 * gamma - 1) * (3 - gamma)\n            - 4 * (gamma - 1) ** 2\n            - (gamma + 1) ** 2 * T5 / T1\n        )\n        c = -2 * (gamma - 1) * (3 - gamma)\n\n        return ((-b + (b**2 - 4 * a * c) ** 0.5) / (2 * a)) ** 0.5\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.__init__","title":"<code>__init__(gamma, MW, *, M=None, u1=None, T1=300, P1=None, T5=None, P5=None)</code>","text":"<p>Solves the ideal shock equations for the following combination of parameters:</p> <ol> <li>Incident shock Mach number (\\(M\\)), or incident shock velocity (\\(u_1\\)), and initial conditions (\\(T_1\\), \\(P_1\\))</li> <li>Reflected shock conditions (\\(T_5\\), \\(P_5\\)) and initial temperature (\\(T_1\\))</li> </ol> <p>given the mixture's specific heat ratio (\\(\\gamma\\)) and mean molecular weight (\\(\\overline{M}\\)). Density is calculated using the ideal gas law:</p> \\[ \\rho = \\frac{P}{RT} \\] <p>where \\(R\\) is the specific gas constant:</p> \\[ R = R_\\text{universal}/\\overline{M} \\] <p>The speed of sound (\\(a\\)) is calculated as:</p> \\[ a = \\sqrt{\\gamma R T} \\] <p>Parameters:</p> Name Type Description Default <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required <code>MW</code> <code>float</code> <p>Molecular weight [g/mol].</p> required <p>Other Parameters:</p> Name Type Description <code>u1</code> <code>float</code> <p>Incident shock velocity [m/s].</p> <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> <code>T1</code> <code>float</code> <p>Initial temperature [K].</p> <code>P1</code> <code>float</code> <p>Initial pressure [Pa].</p> <code>T5</code> <code>float</code> <p>Temperature behind the reflected shock [K].</p> <code>P5</code> <code>float</code> <p>Pressure behind the reflected shock [Pa].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the system is underconstrained/overconstrained.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>def __init__(\n    self,\n    gamma: float,\n    MW: float,\n    *,\n    M: float = None,\n    u1: float = None,\n    T1: float = 300,\n    P1: float = None,\n    T5: float = None,\n    P5: float = None,\n):\n    r\"\"\"\n    Solves the ideal shock equations for the following combination of parameters:\n\n    1. Incident shock Mach number ($M$), or incident shock velocity ($u_1$), and initial conditions ($T_1$, $P_1$)\n    2. Reflected shock conditions ($T_5$, $P_5$) and initial temperature ($T_1$)\n\n    given the mixture's specific heat ratio ($\\gamma$) and mean molecular weight ($\\overline{M}$).\n    Density is calculated using the ideal gas law:\n\n    $$\n    \\rho = \\frac{P}{RT}\n    $$\n\n    where $R$ is the specific gas constant:\n\n    $$\n    R = R_\\text{universal}/\\overline{M}\n    $$\n\n    The speed of sound ($a$) is calculated as:\n\n    $$\n    a = \\sqrt{\\gamma R T}\n    $$\n\n    Arguments:\n        gamma: Specific heat ratio.\n        MW: Molecular weight [g/mol].\n\n    Keyword arguments:\n        u1: Incident shock velocity [m/s].\n        M: Incident shock Mach number.\n        T1: Initial temperature [K].\n        P1: Initial pressure [Pa].\n        T5: Temperature behind the reflected shock [K].\n        P5: Pressure behind the reflected shock [Pa].\n\n    Raises:\n        ValueError: If the system is underconstrained/overconstrained.\n\n    \"\"\"\n\n    R = GAS_CONSTANT / MW\n    a1 = (gamma * R * T1) ** 0.5\n\n    if (M and T1 and P1) or (u1 and T1 and P1):\n        if (M and u1) or T5 or P5:\n            raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n        if M:\n            u1 = M * a1\n        else:\n            M = u1 / a1\n\n        P5 = P1 * IdealShock.reflected_pressure_ratio(M, gamma)\n        T5 = T1 * IdealShock.reflected_temperature_ratio(M, gamma)\n\n    elif T5 and P5 and T1:\n        if P1 or M or u1:\n            raise ValueError(\"Overconstrained - too many arguments provided.\")\n\n        M = IdealShock.incident_Mach_number(gamma, T5, T1)\n        u1 = M * a1\n        P1 = P5 / IdealShock.reflected_pressure_ratio(M, gamma)\n\n    else:\n        raise ValueError(\"Underconstrained - insufficient arguments provided.\")\n\n    P2 = P1 * IdealShock.incident_pressure_ratio(M, gamma)\n    T2 = T1 * IdealShock.incident_temperature_ratio(M, gamma)\n\n    rho1 = P1 / (R * T1)\n    rho2 = P2 / (R * T2)\n    rho5 = P5 / (R * T5)\n\n    u2 = u1 / IdealShock.incident_density_ratio(M, gamma)\n    u5 = u1 * IdealShock.reflected_velocity_ratio(M, gamma)\n\n    super().__init__(u1, T1, P1, rho1, u2, T2, P2, rho2, u5, T5, P5, rho5, MW)\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.from_thermo","title":"<code>from_thermo(thermo, **kwargs)</code>  <code>classmethod</code>","text":"<p>Alternative constructor from a <code>ThermoInterface</code> object.</p> <p>For an ideal gas, the specific heat at constant volume (\\(c_v\\)) is related to the specific heat at constant pressure (\\(c_p\\)) by the gas constant (\\(R\\)):</p> \\[ c_p = c_v + R \\] <p>therefore, the specific heat ratio (\\(\\gamma\\)) is calculated from the available properties as:</p> \\[ \\gamma = \\frac{c_p}{c_p - R} \\] <p>Note</p> <p>\\(c_p\\) is evaluated at the current state of the <code>thermo</code> object; therefore, the calculated \\(\\gamma\\) may differ from the nominal value.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@classmethod\ndef from_thermo(cls, thermo: ThermoInterface, **kwargs):\n    r\"\"\"\n    Alternative constructor from a `ThermoInterface` object.\n\n    For an ideal gas, the specific heat at constant volume ($c_v$) is related to the specific heat\n    at constant pressure ($c_p$) by the gas constant ($R$):\n\n    $$\n    c_p = c_v + R\n    $$\n\n    therefore, the specific heat ratio ($\\gamma$) is calculated from the available properties as:\n\n    $$\n    \\gamma = \\frac{c_p}{c_p - R}\n    $$\n\n    !!! Note\n        $c_p$ is evaluated at the current state of the `thermo` object; therefore, the\n        calculated $\\gamma$ may differ from the nominal value.\n    \"\"\"\n    gamma = thermo.cp_mass / (\n        thermo.cp_mass - GAS_CONSTANT / thermo.mean_molecular_weight\n    )\n    return cls(gamma, thermo.mean_molecular_weight, **kwargs)\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.incident_Mach_number","title":"<code>incident_Mach_number(gamma, T5, T1=1)</code>  <code>staticmethod</code>","text":"<p>Calculates the incident shock Mach number from the ratio of the reflected shock temperature to the initial temperature. Expanding the equation for the reflected temperature ratio yields an equation of the form:</p> \\[ aM^4 + bM^2 + c = 0 \\] <p>where</p> \\[ a = 2(3\\gamma-1)(\\gamma-1) \\] \\[ b = (3\\gamma-1)(3-\\gamma) - 4(\\gamma-1)^2 - \\frac{T_5}{T_1}(\\gamma+1)^2 \\] \\[ c = -2(3-\\gamma)(\\gamma-1) \\] <p>Solving the above equation for \\(M^2\\) using the quadratic formula, then taking the square root of the non-negative solution, yields the incident shock Mach number for the given temperature ratio:</p> \\[ M = \\sqrt{\\frac{-b + \\sqrt{b^2-4ac}}{2a}} \\] <p>Parameters:</p> Name Type Description Default <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required <code>T5</code> <code>float</code> <p>Reflected shock temperature [K].</p> required <code>T1</code> <code>float</code> <p>Initial temperature [K].</p> <code>1</code> <p>Note</p> <p>If <code>T1</code> is not specified, it is assumed that the temperature ratio \\({T_5}/{T_1}\\) is given as <code>T5</code>.</p> Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef incident_Mach_number(gamma: float, T5: float, T1: float = 1):\n    r\"\"\"\n    Calculates the incident shock Mach number from the ratio of the reflected shock\n    temperature to the initial temperature. Expanding the equation for the reflected temperature\n    ratio yields an equation of the form:\n\n    $$\n    aM^4 + bM^2 + c = 0\n    $$\n\n    where\n\n    $$\n    a = 2(3\\gamma-1)(\\gamma-1)\n    $$\n\n    $$\n    b = (3\\gamma-1)(3-\\gamma) - 4(\\gamma-1)^2 - \\frac{T_5}{T_1}(\\gamma+1)^2\n    $$\n\n    $$\n    c = -2(3-\\gamma)(\\gamma-1)\n    $$\n\n    Solving the above equation for $M^2$ using the quadratic formula, then taking the square\n    root of the non-negative solution, yields the incident shock Mach number for the given\n    temperature ratio:\n\n    $$\n    M = \\sqrt{\\frac{-b + \\sqrt{b^2-4ac}}{2a}}\n    $$\n\n    Parameters:\n        gamma: Specific heat ratio.\n        T5: Reflected shock temperature [K].\n        T1: Initial temperature [K].\n\n    !!! Note\n        If `T1` is not specified, it is assumed that the temperature ratio ${T_5}/{T_1}$ is given as `T5`.\n\n    \"\"\"\n    a = 2 * (gamma - 1) * (3 * gamma - 1)\n    b = (\n        (3 * gamma - 1) * (3 - gamma)\n        - 4 * (gamma - 1) ** 2\n        - (gamma + 1) ** 2 * T5 / T1\n    )\n    c = -2 * (gamma - 1) * (3 - gamma)\n\n    return ((-b + (b**2 - 4 * a * c) ** 0.5) / (2 * a)) ** 0.5\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.incident_density_ratio","title":"<code>incident_density_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the density ratio across the incident shock:</p> \\[ \\frac{\\rho_2}{\\rho_1} = \\frac {(\\gamma+1)M^2} {(\\gamma-1)M^2+2} \\] <p>which is also the velocity ratio across the incident shock:</p> \\[ \\frac{u_1}{u_2} = \\frac{\\rho_2}{\\rho_1} \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef incident_density_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the density ratio across the incident shock:\n\n    $$\n    \\frac{\\rho_2}{\\rho_1} = \\frac {(\\gamma+1)M^2} {(\\gamma-1)M^2+2}\n    $$\n\n    which is also the velocity ratio across the incident shock:\n\n    $$\n    \\frac{u_1}{u_2} = \\frac{\\rho_2}{\\rho_1}\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    return (gamma + 1) * M**2 / ((gamma - 1) * M**2 + 2)\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.incident_pressure_ratio","title":"<code>incident_pressure_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the pressure ratio across the incident shock:</p> \\[ \\frac{P_2}{P_1} = \\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1} \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef incident_pressure_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the pressure ratio across the incident shock:\n\n    $$\n    \\frac{P_2}{P_1} = \\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1}\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    return (2 * gamma * M**2 - (gamma - 1)) / (gamma + 1)\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.incident_temperature_ratio","title":"<code>incident_temperature_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the temperature ratio across the incident shock:</p> \\[ \\frac{T_2}{T_1} = \\frac{     \\left(\\gamma M^2 - \\frac{\\gamma-1}{2}\\right)     \\left(\\frac{\\gamma-1}{2}M^2+1\\right) }{     \\left(\\frac{\\gamma+1}{2}\\right)^2 M^2 } \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef incident_temperature_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the temperature ratio across the incident shock:\n\n    $$\n    \\frac{T_2}{T_1} = \\frac{\n        \\left(\\gamma M^2 - \\frac{\\gamma-1}{2}\\right)\n        \\left(\\frac{\\gamma-1}{2}M^2+1\\right)\n    }{\n        \\left(\\frac{\\gamma+1}{2}\\right)^2 M^2\n    }\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    return (\n        (gamma * M**2 - (gamma - 1) / 2)\n        * ((gamma - 1) / 2 * M**2 + 1)\n        / ((gamma + 1) / 2 * M) ** 2\n    )\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.reflected_pressure_ratio","title":"<code>reflected_pressure_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the ratio of the reflected shock pressure to the initial pressure:</p> \\[ \\frac{P_5}{P_1} = \\left[\\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1}\\right] \\left[\\frac{(3\\gamma-1)M^2-2(\\gamma-1)}{(\\gamma-1)M^2+2}\\right] \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef reflected_pressure_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the ratio of the reflected shock pressure to the initial pressure:\n\n    $$\n    \\frac{P_5}{P_1} = \\left[\\frac{2\\gamma M^2-(\\gamma-1)}{\\gamma+1}\\right]\n    \\left[\\frac{(3\\gamma-1)M^2-2(\\gamma-1)}{(\\gamma-1)M^2+2}\\right]\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    return (\n        (2 * gamma * M**2 - (gamma - 1))\n        / (gamma + 1)\n        * ((3 * gamma - 1) * M**2 - 2 * (gamma - 1))\n        / ((gamma - 1) * M**2 + 2)\n    )\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.reflected_temperature_ratio","title":"<code>reflected_temperature_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the ratio of the reflected shock temperature to the initial temperature:</p> \\[ \\frac{T_5}{T_1} = \\frac{\\left[2(\\gamma-1)M^2+(3-\\gamma)\\right] \\left[(3\\gamma-1)M^2-2(\\gamma-1)\\right]} {(\\gamma+1)^2M^2} \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef reflected_temperature_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the ratio of the reflected shock temperature to the initial temperature:\n\n    $$\n    \\frac{T_5}{T_1} = \\frac{\\left[2(\\gamma-1)M^2+(3-\\gamma)\\right]\n    \\left[(3\\gamma-1)M^2-2(\\gamma-1)\\right]}\n    {(\\gamma+1)^2M^2}\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    return (\n        (2 * (gamma - 1) * M**2 + 3 - gamma)\n        * ((3 * gamma - 1) * M**2 - 2 * (gamma - 1))\n        / ((gamma + 1) * M) ** 2\n    )\n</code></pre>"},{"location":"reference/shock/ideal/#rgfrosh.shock.IdealShock.reflected_velocity_ratio","title":"<code>reflected_velocity_ratio(M, gamma)</code>  <code>staticmethod</code>","text":"<p>Calculates the ratio of the reflected shock velocity to the incident shock velocity:</p> \\[ \\frac{V_R}{V_S} = \\frac{2+\\frac{2}{\\gamma-1}\\frac{P_1}{P_2}} {\\frac{\\gamma+1}{\\gamma-1}-\\frac{P_1}{P_2}} \\] <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>Incident shock Mach number.</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio.</p> required Source code in <code>rgfrosh\\shock.py</code> <pre><code>@staticmethod\ndef reflected_velocity_ratio(M: float, gamma: float) -&gt; float:\n    r\"\"\"\n    Calculates the ratio of the reflected shock velocity to the incident shock velocity:\n\n    $$\n    \\frac{V_R}{V_S} = \\frac{2+\\frac{2}{\\gamma-1}\\frac{P_1}{P_2}}\n    {\\frac{\\gamma+1}{\\gamma-1}-\\frac{P_1}{P_2}}\n    $$\n\n    Parameters:\n        M: Incident shock Mach number.\n        gamma: Specific heat ratio.\n    \"\"\"\n    P12 = 1 / IdealShock.incident_pressure_ratio(M, gamma)\n    return (2 + 2 * P12 / (gamma - 1)) / ((gamma + 1) / (gamma - 1) - P12)\n</code></pre>"}]}